% Created 2021-01-12 Tue 21:13
% Intended LaTeX compiler: pdflatex
\documentclass[presentation]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{minted}
\usetheme{Madrid}
\setbeamertemplate{items}[circle]
\author{Scott Mora}
\date{01-2021}
\title{Tiny Idris Program Synthesis}
\hypersetup{
 pdfauthor={Scott Mora},
 pdftitle={Tiny Idris Program Synthesis},
 pdfcreator={Emacs 27.1 (Org mode 9.3)}, 
 pdflang={English}}
\begin{document}

\maketitle

\begin{frame}[fragile]{Motivation}
  \begin{itemize}
  \item Views the structure of data to determine how to proceed.\\
  \item Results in concise code that encourages reuse. \\
  \item However, similar structures can lead to repetitive code.\\
  \item Boilerplate can lead to human error.\\
  \end{itemize}
\end{frame}  

\begin{frame}[fragile]{Data Types \& Function Definitions}
      \begin{block}{Data Types}
        \begin{minted}[]{idris}
          data List : Type -> Type where
             Nil  : List a
             Cons : a -> List a -> List a
        \end{minted}
      \end{block}
      \begin{block}{Instantiated Lists}
        \begin{minted}[]{idris}
          bList : List Boolean
          bList = True :: False :: True :: []

          iList : List Integer
          iList = 1 :: 2 :: 3 :: []
        \end{minted}
      \end{block}
      \begin{block}{Function Definition}
        \begin{minted}[]{idris}
          isEmpty : List a -> Bool
          isEmpty Nil       = True
          isEmpty Cons i is = False
        \end{minted}
      \end{block}
\end{frame}

\begin{frame}[fragile]{Dependent Types}
      \begin{block}{Numbers}
        \begin{minted}[]{idris}
          data Num : Type where
            Zero    : Num
            OnePlus : Num -> Num 
        \end{minted}
      \end{block}
      \begin{block}{Vect}
        \begin{minted}[]{idris}
          data Vect : Num -> Type -> Type where
             Nil  : Vect Zero a
             Cons : a -> Vect n a -> Vect (OnePlus n) a
        \end{minted}
      \end{block}
      \begin{block}{Vect}
        \begin{minted}[]{idris}
          append : Vect n a -> Vect m a -> Vect (n + m) a
          append []        ys = ys
          append (x :: xs) ys = x :: (append xs ys)
        \end{minted}
      \end{block}
\end{frame}

\begin{frame}[fragile]{Specification}
  \begin{itemize}
  \item Tiny Idris is a dependently typed functional language.\\
  \item We aim to extend the language with program synthesis capabilities via holes. 
    \begin{block}{Hole Driven Development in Tiny Idris}
      \begin{minted}[]{idris}
        append : (a : _) -> (n : _) -> (m : _) ->
                 Vect n a -> Vect m a ->
                 Vect (add n m) a
        pat a : Type, m : Num, ys : Vect m a =>
          append a Zero m (Nil a) ys = ?v01
        pat a : Type, n : Num, x : a, xs : Vect n a,
            m : Num, ys : Vect m a =>
          append a (OnePlus n) m (Cons a n x xs) ys
              = ?v02
      \end{minted}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Specialised Systems}
  \begin{itemize}
  \item Specialised tools such as Leon, Myth, Synquid, ReSyn.\\
  \item Began having type information available, but without using it.\\
  \item Relied on input output examples, and other specifications. \\
  \item Progressively use of type information increased.\\
  \item Greatly improved performance when enough type information is
    available.\\
  \item Struggles with less specification, eg. Lists.\\
  \item All require verbose specifications.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Built in to Languages}
  \begin{itemize}
  \item Developed from automatic proof search tools.\\
  \item Can be general or more specialised.\\
  \item Idris has a more general, but limited approach.\\
  \item Agda and Coq have more hardcoded information using tactics languages.\\
  \item Packaged in a more useful manner than synthesis systems.\\
  \item Perform better than earlier systems.\\
  \item Trade offs are made with more advanced systems such as Synquid.\\
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Tiny Idris Implementation}
    \begin{itemize}
    \item Syntax is desugared into RawImp, the high level representation.\\
    \item RawImp is elabourated to TT, the core language used internally.\\
    \item TT expressions can be evaluated to values.\\
    \item Unification checks a sort of equality between terms.\\
    \end{itemize}
\end{frame}  


\begin{frame}[fragile]{Implementation}
  \begin{itemize}
  \item Identified holes during parsing along with required information.\\
  \item RawImp holes are elabourated to the core representation.\\
  \item Uses built in unification to check if guesses are valid.\\
  \item Checks if any local variables are suitable.\\
  \item Checks if any data constructors will
    result in a valid term, and attempts to synthesise arguments, then for function definitions.\\
  \item Each returns a list of candidates which can be sorted based on some
    heuriustic.\\
  \item Unelabourates to RawImp and re-sugars to a string of
    language syntax that may be inserted.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Testing}
  \begin{itemize}
  \item Tests have been divided by common structures,
    each serving a purpose.\\
  \item Lists, Vectors, Equality, Sorting and AVL trees.\\
  \item Vectors are the simplest.\\
  \item Lists test lack of type information.\\
  \item Equality compares to more specialised proof search systems.\\
  \item Sorting looks at case splitting and use of predicates.\\
  \item AVL are considerably larger.\\
  \item Synthesis can be called individually or in batches based
    on files.\\
  \item Two files partially implemented, currently improvements
    are required before more tests are.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Future}
  \begin{itemize}
  \item Improve base functionallity.\\
  \item Finalise the test suite.\\
  \item Introduce pattern matching definitions.\\
  \item Introduce better heuriustics for choosing an acceptable solution.\\
  \item Evaluate the performance at each step.
  \end{itemize}
\end{frame}
\end{document}
