data Eq : (a : Type) -> a -> a -> Type where
  refl : (a : Type) -> (x : a) -> Eq a x x

data Nat : Type where
  Z : Nat
  S : Nat -> Nat

data Vec : Nat -> Type -> Type where
  VNil : (a : Type) -> Vec Z a
  VCons : (a : Type) -> (n : Nat) -> a -> Vec n a -> Vec (S n) a

data List : Type -> Type where
  Nil : (a : Type) -> List a
  Cons : (a : Type) -> a -> List a -> List a


data Bool : Type where
 True : Bool
 False : Bool

ifte : (a : Type) -> Bool -> a -> a -> a
pat a : Type, et : a, ef : a =>
  ifte a True et ef = et
pat a : Type, et : a, ef : a =>
  ifte a False et ef = ef


le : (n : Nat) -> (m : Nat) -> Bool
le Z Z = True
pat m : Nat => 
 le Z (S m) = True
pat n : Nat =>
 le (S n) Z = False
pat n : Nat, m : Nat =>
 le (S n) (S m) = le n m

sorted : (n : Nat) -> Vec n Nat -> Bool
sorted Z (VNil Nat) = True
pat n : Nat, x : Nat =>
 sorted n (VCons Nat n x (VNil Nat)) = True
pat n : Nat, x : Nat, y : Nat, xs : Vec n Nat =>
 sorted (S n) (VCons Nat (S n) x (VCons Nat n y xs)) 
   = ifte Bool (le x y) (sorted n (VCons Nat n y xs)) False

data SortedVec : Nat -> Type where
  SNil : SortedVec Z
  SCons : (n : Nat) -> (m : Nat ) -> (v : Vec m Nat) -> 
	    (Eq Bool True (sorted (S m) (VCons Nat m n v))) -> SortedVec (S m)

add : Nat -> Nat -> Nat
pat n =>
  add Z n = n
pat m : Nat, n : Nat =>
  add (S m) n = S (add m n)

len : (a : Type) -> List a -> Nat
pat a : Type =>
  len a (Nil a) = Z
pat a : Type, x : a, xs : List a =>
  len a (Cons a x xs) = S (len a xs)

listToVec : (a : Type) -> (xs : List a) -> Vec (len a xs) a

vecToList : (a : Type) -> (n : Nat) -> Vec n a -> List a

insert : (m : Nat) -> (n : Nat) -> (v : SortedVec n) -> SortedVec (S n)
