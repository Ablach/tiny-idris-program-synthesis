% Created 2021-01-12 Tue 21:13
% Intended LaTeX compiler: pdflatex
\documentclass[presentation]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{minted}
\usetheme{Madrid}
\author{Scott Mora}
\date{01-2021}
\title{Tiny Idris Program Synthesis - 408 Progress Presentation}
\hypersetup{
 pdfauthor={Scott Mora},
 pdftitle={Tiny Idris Program Synthesis - 408 Progress Presentation},
 pdfcreator={Emacs 27.1 (Org mode 9.3)}, 
 pdflang={English}}
\begin{document}

\maketitle

\begin{frame}[fragile]{Structure}
  \begin{itemize}
  \item {Introduce the structure of functional programs}
  \item {Look at synthesis systems.}
  \item {Look at the current progress.}
  \item {Short demo}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Functional Programming}
  \begin{itemize}
  \item {Uses the structure of data to proceed using
    pattern matching definitions.}
  \item {Lends itself to immutable data structures, limiting
    code with unintended side effects.}
  \item {Functions can be composed allowing for more
    concise code.}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Data Type Declarations}
      \begin{block}{Booleans}
        \begin{minted}[]{idris}
          data Bool : Type where
            True : Bool
            False : Bool
        \end{minted}
      \end{block}
    
      \begin{block}{Lists}
        \begin{minted}[]{idris}
          data IntegerList : Type where
             Nil : IntegerList 
             Cons : Integer -> IntegerList -> IntegerList
        \end{minted}
      \end{block}
\end{frame}

\begin{frame}[fragile]{Type Signatures}
      \begin{block}{isEmpty}
        \begin{minted}[]{idris}
          isEmpty : IntegerList -> Bool
        \end{minted}
      \end{block}
      \begin{block}{max}
        \begin{minted}[]{idris}
          max : IntegerList -> Integer
        \end{minted}
      \end{block}
\end{frame}

\begin{frame}[fragile]{Function Definitions}
      \begin{block}{isEmpty}
        \begin{minted}[]{idris}
          isEmpty : IntegerList -> Bool
          isEmpty Nil       = True
          isEmpty Cons i is = False
        \end{minted}
      \end{block}
\end{frame}

\begin{frame}[fragile]{Polymorphism}
      \begin{block}{Lists}
        \begin{minted}[]{idris}
          data List : Type -> Type where
             Nil  : List a
             Cons : a -> List a -> List a
        \end{minted}
      \end{block}
\end{frame}

\begin{frame}[fragile]{Dependent Types}
      \begin{block}{Numbers}
        \begin{minted}[]{idris}
          data Num : Type where
            Zero : Num
            OnePlus : Num -> Num 
        \end{minted}
      \end{block}
      \begin{block}{Vect}
        \begin{minted}[]{idris}
          data Vect : Num -> Type -> Type where
             Nil  : Vect Zero a
             Cons : a -> Vect n a -> Vect (OnePlus n) a
        \end{minted}
      \end{block}
\end{frame}

\begin{frame}[fragile]{Synthesis}
  \begin{itemize}
  \item Similar structures can lead to repetitive code.
  \item Boilerplate can lead to human error.
  \item We want to search all constructable terms. 
  \item The strong type system can be used to reduce
    the possible terms to a searchable amount. 
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Previous Systems}
  \begin{itemize}
  \item Began using little type information.
  \item Progressively use more, following similar patterns.
  \item Specialised tools such as Leon, Myth, Synquid, ReSyn.
  \item Proof search tools implemented in languages such as
    Agda, Idris and Coq.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Implementation}
  \begin{itemize}
  \item Checks if any local variables are suitable.
  \item Checks if any data constructors will
    result in a valid term, and attempts to synthesise arguments.
  \item Checks if any functions would result in a valid term and
    synthesises arguments if so.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Testing}
  \begin{itemize}
  \item Tests have been divided by common structures.
  \item Lists, Vectors, Equality, Sorting and AVL trees.
  \item Synthesis can be called individually or in batches based
    on files.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Future}
  \begin{itemize}
  \item Improve base functionallity.
  \item Introduce case splitting definitions.
  \item Introduce better heuriustics for choosing an acceptable solution.
  \end{itemize}
\end{frame}
\end{document}
