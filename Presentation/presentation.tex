% Created 2021-01-12 Tue 21:13
% Intended LaTeX compiler: pdflatex
\documentclass[presentation]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{minted}
\usetheme{Madrid}
\author{Scott Mora}
\date{01-2021}
\title{Tiny Idris Program Synthesis - 408 Progress Presentation}
\hypersetup{
 pdfauthor={Scott Mora},
 pdftitle={Tiny Idris Program Synthesis - 408 Progress Presentation},
 pdfcreator={Emacs 27.1 (Org mode 9.3)}, 
 pdflang={English}}
\begin{document}

\maketitle

\begin{frame}[fragile]{Structure}
  \begin{itemize}
  \item {Introduce the structure of functional programs}
  \item {Look at the problem of synthesis.}
  \item {Look at the current progress.}
  \item {Short demo}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Functional Programming}
  \begin{itemize}
  \item {Uses the structure of data to proceed using
    pattern matching definitions.}
  \item {Lends itself to immutable data structures, limiting
    code with unintended side effects.}
  \item {Functions can be composed allowing for more
    concise code.}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Data Type Declarations}
      \begin{block}{Booleans}
        \begin{minted}[]{idris}
          data Bool : Type where
            True : Bool
            False : Bool
        \end{minted}
      \end{block}
    
      \begin{block}{Lists}
        \begin{minted}[]{idris}
          data IntegerList : Type where
             Nil : IntegerList 
             Cons : Integer -> IntegerList -> IntegerList
        \end{minted}
      \end{block}
\end{frame}

\begin{frame}[fragile]{Type Signatures \& Function Definitions}
      \begin{block}{Type Signature}
        \begin{minted}[]{idris}
          isEmpty : IntegerList -> Bool
        \end{minted}
      \end{block}
      \begin{block}{Function Definition}
        \begin{minted}[]{idris}
          isEmpty : IntegerList -> Bool
          isEmpty Nil       = True
          isEmpty Cons i is = False
        \end{minted}
      \end{block}
\end{frame}

\begin{frame}[fragile]{Polymorphism}
      \begin{block}{Lists}
        \begin{minted}[]{idris}
          data List : Type -> Type where
             Nil  : List a
             Cons : a -> List a -> List a
        \end{minted}
      \end{block}
\end{frame}

\begin{frame}[fragile]{Dependent Types}
      \begin{block}{Numbers}
        \begin{minted}[]{idris}
          data Num : Type where
            Zero : Num
            OnePlus : Num -> Num 
        \end{minted}
      \end{block}
      \begin{block}{Vect}
        \begin{minted}[]{idris}
          data Vect : Num -> Type -> Type where
             Nil  : Vect Zero a
             Cons : a -> Vect n a -> Vect (OnePlus n) a
        \end{minted}
      \end{block}
\end{frame}

\begin{frame}[fragile]{Specification}
  \begin{itemize}
  \item Similar structures can lead to repetitive code.
  \item Boilerplate can lead to human error.
  \item Tiny Idris is a dependently typed functional language.
  \item Extend the language with program synthesis capabilities via holes. 
    \begin{block}{Hole Driven Development}
      \begin{minted}[]{idris}
        append : (a : _) -> (n : _) -> (m : _) ->
                 Vect n a -> Vect m a ->
                 Vect (add n m) a
        pat a : Type, m : Num, ys : Vect m a =>
          append a Zero m (Nil a) ys = ?v01
        pat a : Type, n : Num, x : a, xs : Vect n a,
            m : Num, ys : Vect m a =>
          append a (OnePlus n) m (Cons a n x xs) ys
              = ?v02
      \end{minted}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Specialised Systems}
  \begin{itemize}
  \item Specialised tools such as Leon, Myth, Synquid, ReSyn.
  \item Began having type information available, but without using it.
  \item Relied on input output examples, and other specifications. 
  \item Progressively use of type information increased.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Built in to Languages}
  \begin{itemize}
  \item Developed from automatic proof search tools.
  \item Can be general or more specialised.
  \item Idris has a more general approcach.
  \item Agda and Coq have more hardcoded information using tactics.
  \end{itemize}
\end{frame}
\begin{frame}[fragile]{Implementation}
  \begin{itemize}
  \item Identified holes during parsing along with required information.
  \item 'RawImp' holes are elabourated to the core representation.
  \item Uses built in unification to check if guesses are valid.
  \item Checks if any local variables are suitable.
  \item Checks if any data constructors will
    result in a valid term, and attempts to synthesise arguments.
  \item Checks if any functions would result in a valid term and
    synthesises arguments if so.
  \item Each returns a list of candidates which can be sorted based on some
    heuriustic.
  \item Unelabourates to RawImp and re-sugars to a string of
    language syntax that may be inserted.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Testing}
  \begin{itemize}
  \item Tests have been divided by common structures.
  \item Lists, Vectors, Equality, Sorting and AVL trees.
  \item Synthesis can be called individually or in batches based
    on files.
  \item Two files partially implemented, currently improvements
    are required before more tests are.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Future}
  \begin{itemize}
  \item Improve base functionallity.
  \item Finalise the test suite.
  \item Introduce case splitting definitions.
  \item Introduce better heuriustics for choosing an acceptable solution.
  \item Evaluate the performance at each step.
  \end{itemize}
\end{frame}
\end{document}
