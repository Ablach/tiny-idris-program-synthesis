data List : Type -> Type where
     Nil : (a : Type) -> List a
     Cons : (a : Type) -> a -> List a -> List a

data Nat : Type where
     Z : Nat
     S : Nat -> Nat

data Vect : Nat -> Type -> Type where
    VNil : (a : Type) -> Vect Z a
    VCons : (a : Type) -> (n : Nat) -> a -> Vect n a -> Vect (S n) a

add : Nat -> Nat -> Nat
pat n : Nat => 
    add Z n = n
pat n : Nat, m : Nat => 
    add (S n) m = S (add n m)

one : Nat
one = S Z

two : Nat
two = S one

Mul : Nat -> Nat -> Nat



-- TESTS

idN : Nat -> Nat -- pass
pat n : Nat =>
	idN n = ?t1

idBN : Nat -> Nat -> Nat 
pat n : Nat =>
	idBN n = ?t2 -- fail, outputs n should be \ n' => n


vapp : (a : _) -> (n : _) -> (m : _) -> Vect n a -> Vect m a -> Vect (add n m) a
pat a : Type , m : Nat , ys : Vect m a =>
	vapp a Z m (VNil a) ys = ?t3 -- pass
pat a : Type , n : Nat , x : a , xs : Vect n a, m : Nat , ys : Vect m a =>
    	vapp a (S n) m (VCons a n x xs) ys
        	= ?t4 -- no match

